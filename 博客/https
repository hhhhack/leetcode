/*
 * 
 * 　　┏┓　　　┏┓+ +
 * 　┏┛┻━━━┛┻┓ + +
 * 　┃　　　　　　　┃ 　
 * 　┃　　　━　　　┃ ++ + + +
 *  ████━████ ┃+
 * 　┃　　　　　　　┃ +
 * 　┃　　　┻　　　┃
 * 　┃　　　　　　　┃ + +
 * 　┗━┓　　　┏━┛
 * 　　　┃　　　┃　　　　　　　　　　　
 * 　　　┃　　　┃ + + + +
 * 　　　┃　　　┃
 * 　　　┃　　　┃ +  神兽保佑
 * 　　　┃　　　┃    代码无bug　　
 * 　　　┃　　　┃　　+　　　　　　　　　
 * 　　　┃　 　　┗━━━┓ + +
 * 　　　┃ 　　　　　　　┣┓
 * 　　　┃ 　　　　　　　┏┛
 * 　　　┗┓┓┏━┳┓┏┛ + + + +
 * 　　　　┃┫┫　┃┫┫
 * 　　　　┗┻┛　┗┻┛+ + + +
 * 
 * 
 * @Author: hhhhack
 * @Date: 2020-12-19 17:18:59
 * @LastEditTime: 2021-03-02 21:45:33
 * @LastEditors: hhhhack
 * @Description: 
 * @FilePath: /code/leetcode/博客/https
 * @
 */


http 
0.9 非正式版
1.0 正式版 支持 put,get,head,option,delete,patch
1.1 升级版 
      支持长连接和pipeline,默认开启keep-alive
      host头处理,存在一个服务器上部署多个服务且ip相同的情况,为了区分服务会在请求和响应头加host域
      带宽优化,在http头增加range字段，可以选择只请求资源的某个部分
      增加错误码类型
      在http头引入更多缓存控制策略的字段
2.0 最新版
      二进制传输,http1.x基于文本解析,http2使用二进制格式传输
      多路复用,同一个连接有多个请求,和keep-alive不同,keep-alive本身是指不释放连接,但是请求任是一个request-一个response,
            也就是只有等上一个请求完成才能开始下一个请求,同一时间只有一个请求,
            但是http2不用,多个请求可以同时进行,通过request_id区分
      http头压缩,减少http部消耗的网络资源
            客户端和服务端维护一份同样的静态头部字典,包含常见头部字段
            维护一份共同的动态头部字典,可以动态的添加内容
            使用哈夫曼编码压缩头部信息
            具体实现:
                  1.对于整个键值对都在字典里的值
                    0   1   2   3   4   5   6   7
                  +---+---+---+---+---+---+---+---+
                  | 1 |        Index (7+)         |
                  +---+---------------------------+
                  第一位用1表示,后7位表示字典里的key如字典里2:"method:get" 则头部值为10000010
                  2.头部名称在字典里,更新动态字典
                  0   1   2   3   4   5   6   7
                  +---+---+---+---+---+---+---+---+
                  | 0 | 1 |      Index (6+)       |
                  +---+---+-----------------------+
                  | H |     Value Length (7+)     |
                  +---+---------------------------+
                  | Value String (Length octets)  |
                  +-------------------------------+
                  前两位01表示这个是header的key的索引,后面的字节第一位表示是否使用哈夫曼编码,后7位表示字段长度
                  3.头部不在字典
                  0   1   2   3   4   5   6   7
                  +---+---+---+---+---+---+---+---+
                  | 0 | 1 |           0           |
                  +---+---+-----------------------+
                  | H |     Name Length (7+)      |
                  +---+---------------------------+
                  |  Name String (Length octets)  |
                  +---+---------------------------+
                  | H |     Value Length (7+)     |
                  +---+---------------------------+
                  | Value String (Length octets)  |
                  +-------------------------------+
                  和上一个类似,只是索引为0,增加了一个key的字段
                  4.头部在字典里,不允许更新动态字典
                  0   1   2   3   4   5   6   7
                  +---+---+---+---+---+---+---+---+
                  | 0 | 0 | 0 | 1 |  Index (4+)   |
                  +---+---+-----------------------+
                  | H |     Value Length (7+)     |
                  +---+---------------------------+
                  | Value String (Length octets)  |
                  +-------------------------------+
                  和第二种类似,只是索引字段为0001
                  5.头部不在字典,不允许更新动态字典
                  0   1   2   3   4   5   6   7
                  +---+---+---+---+---+---+---+---+
                  | 0 | 0 | 0 | 1 |       0       |
                  +---+---+-----------------------+
                  | H |     Name Length (7+)      |
                  +---+---------------------------+
                  |  Name String (Length octets)  |
                  +---+---------------------------+
                  | H |     Value Length (7+)     |
                  +---+---------------------------+
                  | Value String (Length octets)  |
                  +-------------------------------+
                  和第三种类似,只是同样索引的前四位为0001
      服务器推送
3.0 quic协议
      http2存在的问题:1.header阻塞,http2采用tcp协议,虽然在http协议层面解决了header阻塞,但是在tcp层面仍然存在,
            如果一个tcp包丢失,那么后续的包就失效了
      quic是基于udp和http2
      特点:初次1RTT握手,拥有tcp的流量控制,超时重传,拥塞控制,同时避免了队首阻塞,连接迁移
      1. 0RTT建立连接
            http1/http2需要3RTT建立加密连接,tls握手则总共需要2TRR
            c              s
               syn ----->
               <----syn/ack //1RTT
               ack----->
               clienthello->
               ca,resp<--    //2RTT
               key----->
               <-------resp  //3RTT
            http3初始连接只需要1RTT : DH密钥交换算法
            client                    server
                  client hello------>
                                          A=g^a mod p
                  <-------------g,p,A
            B=g^b mod p
            K=A^b mod p
                  B ---------------->
                                          K=B^a mod p
            后续客户端保存了服务端配置可以0RTT建立连接

      2. 连接迁移
            tcp使用四元组保持连接,QUIC使用64位connection id保持连接

      3. 多路复用
            http1.1存在http队头阻塞和tcp队头阻塞,如果一个http头丢失,那么整个请求被阻塞
            http2 解决了http队头阻塞,如果一个http头阻塞,复用的其他http请求可以继续
                  但是如果一个tcp包丢失,那么整个连接还是必须等待对端重发,
                  同时tls协议存在队头阻塞,TLS 基于 Record 组织数据,将一堆数据放在一起(即一个Record)加密,
                  加密完后又拆分成多个TCP包传输。一般每个Record16K,包含12个TCP包,这样如果12个TCP包中有任何一个包丢失,
                  那么整个Record都无法解密。
            http3 决了tcp的队头阻塞和tls阻塞,QUIC基于packet传输,也基于packet加密从而避免tls队头阻塞
                  QUIC基于udp,udp连接本身不要求包有序,所以在传输层不会队头阻塞
      4. 拥塞控制
            1. quic的拥塞控制在应用层,便于修改
            2. quic使用前向纠错
            3. quic使用单调递增packetnumber,tcp在超时重传后由于收到的包的seqnum不确定是重传的还是之前的,会影响RTT计算
                  quic使用递增packetnum则不会
            4. 更多ack块,tcp使用3个ack块,每收到三个包都需要回一个ack,quic则有256个ack块
            5. 流量控制
                  每个stream一个拥塞窗口


http报文格式

      request：
      方法 |url |版本 |换行符
      头部字段名：值 |换行符
      。。。。。。
      头部字段名：值 |换行符
      换行符
      请求内容

      response：
      版本 |状态码 |短语 |换行符
      头部字段名：值 |换行符
      。。。。。。
      头部字段名：值 |换行符
      换行符
      响应内容

http状态码
      1** 信息, 服务器收到请求，正在处理，需要客户端继续操作
            100 继续，客户端继续该请求
            101 切换协议
      2** 成功，服务器收到请求，并处理成功
            200 请求成功
            201 已创建新的资源
            202 已接受，但未完成
      3** 重定向，需要进一步操作完成请求
            300 多种选择
            301 永久移动
            302 临时移动
      4** 客户端错误
      5** 服务端错误

https

https = http + ssl
http负责具体的通信内容，ssl负责建立加密信道

ssl：
client                                                      server
      client hello, random1, 支持的加密方式---------->
      <------------------------random2, 匹配的加密方式
      <-------------------------------------服务端证书
      (证书通常是第三方受信机构颁发，包括服务端公钥，第三
      方的机构签名)

校验证书
生成随机数
生成会话秘钥
      通过公钥加密的随机数--------------------------->
                                                            获取随机数
                                                            生成相同的会话密钥
      发送通过会话秘钥加密的信息--------------------->
      <----------------------发送会话秘钥加密的响应信息



怎么防止中间人劫持： ca签名

服务端将证书信息和公钥发送给受信机构
受信机构将证书信息hash成摘要
受信机构将摘要用私钥加密生成签名
受信机构将加密信息和公钥，签名生成ca证书

客户端：
通过受信机构的公钥解密ca证书获取摘要，证书信息，公钥
hash服务器证书信息获取摘要
比较服务器证书摘要和ca证书的解密摘要
