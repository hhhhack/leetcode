/*
 * 
 * 　　┏┓　　　┏┓+ +
 * 　┏┛┻━━━┛┻┓ + +
 * 　┃　　　　　　　┃ 　
 * 　┃　　　━　　　┃ ++ + + +
 *  ████━████ ┃+
 * 　┃　　　　　　　┃ +
 * 　┃　　　┻　　　┃
 * 　┃　　　　　　　┃ + +
 * 　┗━┓　　　┏━┛
 * 　　　┃　　　┃　　　　　　　　　　　
 * 　　　┃　　　┃ + + + +
 * 　　　┃　　　┃
 * 　　　┃　　　┃ +  神兽保佑
 * 　　　┃　　　┃    代码无bug　　
 * 　　　┃　　　┃　　+　　　　　　　　　
 * 　　　┃　 　　┗━━━┓ + +
 * 　　　┃ 　　　　　　　┣┓
 * 　　　┃ 　　　　　　　┏┛
 * 　　　┗┓┓┏━┳┓┏┛ + + + +
 * 　　　　┃┫┫　┃┫┫
 * 　　　　┗┻┛　┗┻┛+ + + +
 * 
 * 
 * @Author: hhhhack
 * @Date: 2020-12-28 10:42:07
 * @LastEditTime: 2021-03-04 11:19:17
 * @LastEditors: hhhhack
 * @Description: 
 * @FilePath: /code/leetcode/博客/c++
 * @
 */

1. return的时候函数控制权返回给调用者，会自动调用析构函数，exit直接把控制权返回给操作系统，不会直接调用析构函数，所以对c而言是一样的，c++不同
2. 类大小计算:
    (1) 空类大小为1字节,空类的子类大小为1(单继承和多继承)
    (2) 类中静态数据，虚函数，成员函数不占用实例对象空间
    (3) 对象实例大小 = 非静态成员 + 静态成员 + 虚函数指针(只有声明有虚函数的时候才会自动添加,指向虚函数列表,多继承会有多个虚函数指针)
        单继承：
            class A                     [  val_1 ]
                val_1                   [ vfptr * ] -> func(1)
                virtual func(1)     

            class B(A)                  [   val_1, val_2  ]    
                val_2                   [ vfptr * ] -> [func(1), func(2) ]
                virtual func(2)
        多继承:
            class A                 class B                 class C
                val_1                   val_2                   val_3
                virtual func(1)         virtual func(2)         virtual func(3)
                virtual func(2)'        virtual func(1)'        virtual func(1)''
            
            class D(A, B, C)                [ vfptr1* ] -> [ func(1)''', func(2)', func(4) ]
                val_4                       [ val_1 ]
                virtual func(1)'''          [ vfptr2* ] -> [ func(2), func(1)''' ]
                virtual func(4)             [ val_2 ]
                                            [ vfptr3* ] -> [ func(3), func(1)''' ]
                                            [ val_3 ]
                                            [ val_4 ]
        1）虚函数表在最前面的位置。
        2）成员变量根据其继承和声明顺序依次放在后面。
        3）每个父类都有自己的虚表。
        4）子类的成员函数被放到了第一个父类的表中。
        5）内存布局中，其父类布局依次按声明顺序排列。
        6）每个父类的虚表中的f()函数都被overwrite成了子类的f()。这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。

    (4) 虚继承通过虚基类指针列表
        虚继承的基类在类的最后,需要虚基类指针vbptr指向虚基类

                                                  B VTable
                                          +---------------------+
                                          |   vbase_offset(16)  |
                                          +---------------------+
                                          |   offset_to_top(0)  |
struct B                                  +---------------------+
object                                    |      RTTI for B     |
    0 - vptr_B -------------------------> +---------------------+
    8 - int bx                            |       B::f0()       |
   16 - struct A                          +---------------------+
   16 -   vptr_A --------------+          |   vcall_offset(0)   |x--------+
   24 -   int ax               |          +---------------------+         |
                               |          |   vcall_offset(-16) |o----+   |
                               |          +---------------------+     |   |
                               |          |  offset_to_top(-16) |     |   |
                               |          +---------------------+     |   |
                               |          |      RTTI for B     |     |   |
                               +--------> +---------------------+     |   |
                                          |     Thunk B::f0()   |o----+   |
                                          +---------------------+         |
                                          |       A::bar()      |x--------+
                                          +---------------------+



                                                  D VTable
                                          +---------------------+
                                          |   vbase_offset(32)  |
                                          +---------------------+
struct D                                  |   offset_to_top(0)  |
object                                    +---------------------+
    0 - struct B (primary base)           |      RTTI for D     |
    0 -   vptr_B  ----------------------> +---------------------+
    8 -   int bx                          |       D::f0()       |
   16 - struct C                          +---------------------+
   16 -   vptr_C  ------------------+     |   vbase_offset(16)  |
   24 -   int cx                    |     +---------------------+
   28 - int dx                      |     |  offset_to_top(-16) |
   32 - struct A (virtual base)     |     +---------------------+
   32 -   vptr_A --------------+    |     |      RTTI for D     |
   40 -   int ax               |    +---> +---------------------+
sizeof(D): 48    align: 8      |          |       D::f0()       |
                               |          +---------------------+
                               |          |   vcall_offset(0)   |x--------+
                               |          +---------------------+         |
                               |          |   vcall_offset(-32) |o----+   |
                               |          +---------------------+     |   |
                               |          |  offset_to_top(-32) |     |   |
                               |          +---------------------+     |   |
                               |          |      RTTI for D     |     |   |
                               +--------> +---------------------+     |   |
                                          |     Thunk D::f0()   |o----+   |
                                          +---------------------+         |
                                          |       A::bar()      |x--------+
                                          +---------------------+     

3. 智能指针
    c++11 weak_ptr, share_ptr, unique_ptr
        1)使用RAII技术,即资源获取即初始化(定义一个类来管理资源,把资源当作对象来管理类的构造函数即分配资源,类的析构函数即释放资源)
        2)如果对象是用声明的方式分配在栈上的局部对象,那么很容易做到自动释放销毁资源
        share_ptr: 采用引用计数的方式,拷贝的时候计数加1,赋值的时候计数减1,每析构一次计数减1,计数为0自动删除资源
        weak_ptr: 为了解决share_ptr循环引用的问题
        unique_ptr: 在离开其作用域时自动释放,不能拷贝
    如果需要跨作用域使用share_ptr,如果只读取资源,不管理资源使用weak_ptr,如果时独占的局部资源,使用unique_ptr

4. 纯虚函数
    定义 : virtual 返回值类型 函数名 (函数参数) = 0;
    保函纯虚函数的类是抽象类 ---> 无法实例化
    派生类必须实现纯虚类才能实例化

5. 类的默认函数
    1. 默认构造函数 -> 初始化类,
        在new的时候调用, 
        可以重载,
        不能为虚函数,不能有返回值
        有初始化列表和函数体内赋值两种初始化方式,初始化列表效率更高
        函数体内能使用this指针,初始化列表不行,构造函数是对对象赋值,所以已经有对象了
        构造顺序:
            1. 虚基类构造函数
            2. 非虚基类构造函数(按照继承顺序而不是初始化顺序)
            3. 成员对象的构造函数(按照声明顺序)
            4. 本类的构造函数
    2. 默认拷贝构造函数 -> 用一个已有的对象创建另一个对象
        第一个参数是同类型对象的引用
        默认生成的拷贝构造函数只执行浅拷贝
        返回值是对象的引用
    3. 析构函数
        析构函数可以为虚函数
        调用顺序和构造函数相反
    4. 重载赋值运算符 -> 一个对象对另一个已存在的对象赋值
        两个对象赋值的时候调用
        返回类对象的引用
        默认浅拷贝
    5. 重载取值运算符
        没有参数
        默认返回 this指针
    6. 移动构造函数和重载移动赋值操作符
        move语义:将a的所有资源转移给b,用于a初始化b后,a就析构
        和构造函数和拷贝构造函数的参数不同,这两个是左值引用,而移动构造函数是右值引用
        临时对象即将销毁,而它的资源还需要使用可以使用移动构造函数,减少拷贝带来的性能开销

new和malloc的比较：

(1).new失败时会调用new_handler处理函数,malloc不会,失败时返回NULL；
(2).new能通过placement new自动调用对象的构造函数，malloc不会；
(3).new出来的东西是带类型的，malloc是void*，需要强制转换；
(4).new是C++运算符，malloc是C标准库函数。

对象创建（new）过程：

(1).通过operator new申请内存；
(2).使用placement new调用构造函数(简单类型忽略此步);
(3).返回内存指针。

new的三种形态：new operator,operator new,placement new
  (1).new operator：上面所说的new就是new operator，共有三个步骤组成（申请内存，调用构造函数，返回内存指针），对于申请内存步骤是通过运算符new(operator new)完成的，对于调用什么构造函数，可以由placement new决定；
  (2).operator new：像普通运算符一样可以被重载，operator new会去申请内存，申请失败的时候会调用new_handler处理，这是一个循环的过程，如果new_handler不抛出异常，会一直循环申请内存，直到成功；
  (3).placement new：用于定位构造函数，在指定的内存地址上用指定类型的构造函数构造对象

6. voliate:告诉编译器,该变量不优化,每次从内存读取

c++11特性
    1.智能指针
        share_ptr
        unique_ptr
        weak_ptr
    2.lambda表达式
    3.类型推导
        auto关键字
        decltype关键字
    4.基于范围的for循环
        旧版
            for(<stltype>::iterator i = v.begin();i != v.end(); i++){
                ...
            }
        新版
            for(auto d:v){
                ...
            }
    5.右值引用和移动语义
        右值引用 T &&

stl:
    容器: 数据结构模板
        序列容器: vector<> 数组
        排序容器:
    算法:
    迭代器
    仿函数
    适配器
    内存分配器
        
