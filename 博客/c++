/*
 * 
 * 　　┏┓　　　┏┓+ +
 * 　┏┛┻━━━┛┻┓ + +
 * 　┃　　　　　　　┃ 　
 * 　┃　　　━　　　┃ ++ + + +
 *  ████━████ ┃+
 * 　┃　　　　　　　┃ +
 * 　┃　　　┻　　　┃
 * 　┃　　　　　　　┃ + +
 * 　┗━┓　　　┏━┛
 * 　　　┃　　　┃　　　　　　　　　　　
 * 　　　┃　　　┃ + + + +
 * 　　　┃　　　┃
 * 　　　┃　　　┃ +  神兽保佑
 * 　　　┃　　　┃    代码无bug　　
 * 　　　┃　　　┃　　+　　　　　　　　　
 * 　　　┃　 　　┗━━━┓ + +
 * 　　　┃ 　　　　　　　┣┓
 * 　　　┃ 　　　　　　　┏┛
 * 　　　┗┓┓┏━┳┓┏┛ + + + +
 * 　　　　┃┫┫　┃┫┫
 * 　　　　┗┻┛　┗┻┛+ + + +
 * 
 * 
 * @Author: hhhhack
 * @Date: 2020-12-28 10:42:07
 * @LastEditTime: 2021-02-01 19:28:09
 * @LastEditors: hhhhack
 * @Description: 
 * @FilePath: /code/leetcode/博客/c++
 * @
 */

1. return的时候函数控制权返回给调用者，会自动调用析构函数，exit直接把控制权返回给操作系统，不会直接调用析构函数，所以对c而言是一样的，c++不同
2. 类大小计算:
    (1) 空类大小为1字节,空类的子类大小为1(单继承和多继承)
    (2) 类中静态数据，虚函数，成员函数不占用实例对象空间
    (3) 对象实例大小 = 非静态成员 + 静态成员 + 虚函数指针(只有声明有虚函数的时候才会自动添加,指向虚函数列表,多继承会有多个虚函数指针)
        单继承：
            class A                     [  val_1 ]
                val_1                   [ vfptr * ] -> func(1)
                virtual func(1)     

            class B(A)                  [   val_1, val_2  ]    
                val_2                   [ vfptr * ] -> [func(1), func(2) ]
                virtual func(2)
        多继承:
            class A                 class B                 class C
                val_1                   val_2                   val_3
                virtual func(1)         virtual func(2)         virtual func(3)
                virtual func(2)'        virtual func(1)'        virtual func(1)''
            
            class D(A, B, C)                [ vfptr1* ] -> [ func(1)''', func(2)', func(4) ]
                val_4                       [ val_1 ]
                virtual func(1)'''          [ vfptr2* ] -> [ func(2), func(1)''' ]
                virtual func(4)             [ val_2 ]
                                            [ vfptr3* ] -> [ func(3), func(1)''' ]
                                            [ val_3 ]
                                            [ val_4 ]
        1）虚函数表在最前面的位置。
        2）成员变量根据其继承和声明顺序依次放在后面。
        3）每个父类都有自己的虚表。
        4）子类的成员函数被放到了第一个父类的表中。
        5）内存布局中，其父类布局依次按声明顺序排列。
        6）每个父类的虚表中的f()函数都被overwrite成了子类的f()。这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。

    (4) 虚继承通过虚基类指针列表
        虚继承的基类在类的最后,需要虚基类指针vbptr指向虚基类

                                                  B VTable
                                          +---------------------+
                                          |   vbase_offset(16)  |
                                          +---------------------+
                                          |   offset_to_top(0)  |
struct B                                  +---------------------+
object                                    |      RTTI for B     |
    0 - vptr_B -------------------------> +---------------------+
    8 - int bx                            |       B::f0()       |
   16 - struct A                          +---------------------+
   16 -   vptr_A --------------+          |   vcall_offset(0)   |x--------+
   24 -   int ax               |          +---------------------+         |
                               |          |   vcall_offset(-16) |o----+   |
                               |          +---------------------+     |   |
                               |          |  offset_to_top(-16) |     |   |
                               |          +---------------------+     |   |
                               |          |      RTTI for B     |     |   |
                               +--------> +---------------------+     |   |
                                          |     Thunk B::f0()   |o----+   |
                                          +---------------------+         |
                                          |       A::bar()      |x--------+
                                          +---------------------+



                                                  D VTable
                                          +---------------------+
                                          |   vbase_offset(32)  |
                                          +---------------------+
struct D                                  |   offset_to_top(0)  |
object                                    +---------------------+
    0 - struct B (primary base)           |      RTTI for D     |
    0 -   vptr_B  ----------------------> +---------------------+
    8 -   int bx                          |       D::f0()       |
   16 - struct C                          +---------------------+
   16 -   vptr_C  ------------------+     |   vbase_offset(16)  |
   24 -   int cx                    |     +---------------------+
   28 - int dx                      |     |  offset_to_top(-16) |
   32 - struct A (virtual base)     |     +---------------------+
   32 -   vptr_A --------------+    |     |      RTTI for D     |
   40 -   int ax               |    +---> +---------------------+
sizeof(D): 48    align: 8      |          |       D::f0()       |
                               |          +---------------------+
                               |          |   vcall_offset(0)   |x--------+
                               |          +---------------------+         |
                               |          |   vcall_offset(-32) |o----+   |
                               |          +---------------------+     |   |
                               |          |  offset_to_top(-32) |     |   |
                               |          +---------------------+     |   |
                               |          |      RTTI for D     |     |   |
                               +--------> +---------------------+     |   |
                                          |     Thunk D::f0()   |o----+   |
                                          +---------------------+         |
                                          |       A::bar()      |x--------+
                                          +---------------------+     

3. 智能指针
    c++11 weak_ptr, share_ptr, unique_ptr
        1)使用RAII技术,即资源获取即初始化(定义一个类来管理资源,把资源当作对象来管理类的构造函数即分配资源,类的析构函数即释放资源)
        2)如果对象是用声明的方式分配在栈上的局部对象,那么很容易做到自动释放销毁资源
        share_ptr: 采用引用计数的方式,拷贝的时候计数加1,赋值的时候计数减1,每析构一次计数减1,计数为0自动删除资源
        weak_ptr: 为了解决share_ptr循环引用的问题
        unique_ptr: 在离开其作用域时自动释放,不能拷贝
    如果需要跨作用域使用share_ptr,如果只读取资源,不管理资源使用weak_ptr,如果时独占的局部资源,使用unique_ptr

4. 纯虚函数
    定义 : virtual 返回值类型 函数名 (函数参数) = 0;
    保函纯虚函数的类是抽象类 ---> 无法实例化
    派生类必须实现纯虚类才能实例化

5. 类的默认函数
    1. 默认构造函数 -> 初始化类,
        在new的时候调用, 
        可以重载,
        不能为虚函数,不能有返回值
        有初始化列表和函数体内赋值两种初始化方式,初始化列表效率更高
        函数体内能使用this指针,初始化列表不行,
    2. 默认拷贝构造函数 -> 